(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{232:function(n,t,r){"use strict";r.r(t);var e=r(0),a=Object(e.a)({},(function(){var n=this,t=n.$createElement,r=n._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[r("h2",{attrs:{id:"一、算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、算法","aria-hidden":"true"}},[n._v("#")]),n._v(" 一、算法")]),n._v(" "),r("blockquote",[r("p",[n._v("前端工程师吃饭的家伙，深度、广度一样都不能差。")])]),n._v(" "),r("h3",{attrs:{id:"排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#排序","aria-hidden":"true"}},[n._v("#")]),n._v(" 排序")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  \t// 插入排序\n    function insertSort(array) {\n      for (let i = 1; i < array.length; i++) {\n        let target = i;\n        for(let j = i - 1; j >= 0; j--) {\n          if(array[target] < array[j]) {\n            [array[target], array[j]] = [array[j], array[target]];\n            target = j;\n          } else {\n            break;\n          }\n        }\n      }\n    }\n\n    // 选择排序\n    function selectionSort(array) {\n    \tfor (let i = 0; i < array.length; i++) {\n    \t\tlet minIndex = i;\n    \t\tfor (let j = i + 1; j < array.length; j++) {\n    \t\t\tif (array[j] < array[minIndex]) {\n    \t\t\t\tminIndex = j;\n    \t\t\t}\n    \t\t}\n\n    \t\t[array[j], array[minIndex]] = [array[minIndex], array[j]];\n    \t}\n    }\n\n    // 归并排序\n    function mergeSort(array) {\n    \tconst len = array.length;\n    \tif (len < 2) {\n    \t\treturn array;\n    \t}\n\n    \tconst mid = Math.floor(len / 2);\n    \tconst first = array.slice(0, mid);\n    \tconst last = array.slice(mid);\n\n    \treturn merge(mergeSort(first), mergeSort(last));\n    }\n    function merge(left, right) {\n    \tlet result = [];\n    \twhile(left.length && right.length) {\n    \t\tif (left[0] <= right[0]) {\n    \t\t\tresult.push(left.shift());\n    \t\t} else {\n    \t\t\tresult.push(right.shift());\n    \t\t}\n    \t}\n    \twhile(left.length) {\n    \t\tresult.push(left.shift());\n    \t}\n    \twhile(right.length) {\n    \t\tresult.push(right.shift());\n    \t}\n\n    \treturn result;\n    } \n\n    // 快速排序\n    function quickSort(array) {\n    \tif (array.length < 2) {\n    \t\treturn array;\n    \t}\n    \tlet target = array[0];\n    \tlet left = [];\n    \tlet right = [];\n\n    \tfor (let i = 1; i < array.length; i++) {\n    \t\tif (array[i] < target) {\n    \t\t\tleft.push(array[i]);\n    \t\t} else {\n    \t\t\tright.push(array[i])\n    \t\t}\n    \t}\n    \treturn quickSort(left).concat([target], quickSort(right));\n\n    }\n\n\n    // 冒泡排序\n    function bubbleSort(array) {\n    \tfor (let i = 0; i < array.length; i++) {\n    \t\tlet complete = true;\n    \t\tfor(let j = 0; j < array.length - 1 - i; j++) {\n    \t\t\t// 比较相邻数\n    \t\t\tif (array[j] > array[j + 1]) {\n    \t\t\t\t[array[j], array[j + 1]] = [array[j + 1], array[j]];\n    \t\t\t\tcomplete = false;\n    \t\t\t}\n    \t\t}\n\n    \t\tif (complete) {\n    \t\t\tbreak;\n    \t\t}\n    \t}\n    \treturn array;\n    }\n    // 冒泡优化版\n    function bubbleSort(array) {\n        let i = array.length - 1;\n        while(i > 0) {\n            let pos = 0;\n\n            for (let j = 0; j < i; j++) {\n                if (array[j] > array[j + 1]) {\n                    pos = j\n                    [array[j], array[j + 1]] = [array[j + 1], array[j]];\n                }\n            }\n            i = pos\n        }\n        return array\n    }\n")])])]),r("h3",{attrs:{id:"二分法查找"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二分法查找","aria-hidden":"true"}},[n._v("#")]),n._v(" 二分法查找")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  \tfunction binarySearch(target, array) {\n    \tlet max = array.length - 1;\n    \tlet min = 0;\n\n    \twhile (min >= max) {\n    \t\tlet mid = Math.floor((max + min) / 2);\n    \t\tif (target > array[mid]) {\n    \t\t\tmin = mid + 1;\n    \t\t}  else if (target < array[mid]) {\n    \t\t\tmax = mid - 1;\n    \t\t} else {\n    \t\t\treturn mid;\n    \t\t}\n    \t}\n    \treturn -1;\n\n    }\n")])])]),r("h3",{attrs:{id:"数组交集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组交集","aria-hidden":"true"}},[n._v("#")]),n._v(" 数组交集")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("  \tfunction intersect(m, n) {\n      let hash = {};\n      let arr = [];\n      for (let i = 0; i < m.length; i++) {\n        let v = m[i];\n        hash[v] ? hash[v] += 1 : hash[v] = 1\n      }\n\n      for (let i = 0; i < n.length; i++) {\n        let v = n[i]\n        if (hash[v] && hash[v] > 0) {\n          arr.push(v)\n          hash[v] -= 1\n        } \n        \n      }\n      return arr\n    }\n")])])]),r("h3",{attrs:{id:"深度优先算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先算法","aria-hidden":"true"}},[n._v("#")]),n._v(" 深度优先算法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v(" /**\n * 递归方法\n * @param {Object} node 节点\n * @param {Array} nodeList 节点结合\n */\n function deepTree(node, nodeList=[]) {\n  if (node) {\n    nodeList.push(node)\n    let children = node.children;\n    for (let i = 0; i < children.length; i++) {\n      deepTree(children[i], nodeList)\n    }\n  }\n  return nodeList;\n }\n\n /**\n * 栈方法\n * @param {Object} node 节点\n * @param {Array} nodeList 节点结合\n */\n function deepTree2(node) {\n  let nodes = [];\n  let stack = [];\n  if (node) {\n    stack.push(node);\n\n    while(stack.length) {\n      let item = stack.pop();\n      let children = item.children;\n      nodes.push(item);\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        stack.push(children[i])\n      }\n    }\n  }\n  return nodes;\n }\n")])])]),r("h3",{attrs:{id:"广度优先算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先算法","aria-hidden":"true"}},[n._v("#")]),n._v(" 广度优先算法")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("/**\n * 广度优先算法 队列方法\n * @param {Object} node 节点\n * @param {Array} nodeList 节点结合\n */\n function widthTree(node) {\n  let nodes = [];\n  let stack = [];\n  if (node) {\n    stack.push(node);\n    while(stack.length) {\n      let item = stack.shift();\n      let children = item.children;\n      nodes.push(item)\n\n      for (let i = 0; i < children.length; i++) {\n        stack.push(children[i])\n      }\n    }\n  }\n  return nodes;\n }\n")])])]),r("h3",{attrs:{id:"深拷贝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[n._v("#")]),n._v(" 深拷贝")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v(" /**\n * 深拷贝 广度优先算法\n * @param {Array | Object} \n * @return {Array | Object} \n */\n function getEmpty(o) {\n   if(Object.prototype.toString.call(orogin) === '[Object Array]') {\n     return [];\n   }\n   if(Object.prototype.toString.call(orogin) === '[Object Object]') {\n     return {};\n   }\n   return o;\n }\n  function deepCopyBFS(origin) {\n    let stack = [];\n    let map = new Map();\n\n    let target = getEmpty(origin);\n    if (target != origin) {\n      stack.push([origin, target])\n      map.set(origin, target);\n    }\n\n    while(stack.length) {\n      let [ori, tar] = stack.shift();\n      for (let key in ori) {\n\n        // 处理循环引用\n        if (map.get(ori[key])) {\n          tar[key] = map.get(ori[key]);\n          continue;\n       }\n\n       tar[key] = getEmpty(ori[key]);\n       if (ori[key] != tar[key]) {\n         stack.push([ori[key], tar[key]])\n         map.set([ori[key], tar[key]]);\n       }\n      }\n    }\n    \n    return target;\n  }\n\n  /**\n   * 深拷贝 深度优先算法\n   * @param {Array | Object} \n   * @return {Array | Object} \n   */\n  function deepCopyDFS(origin) {\n   let stack = [];\n   let map = new Map();\n\n   let target = getEmpty(origin);\n   if (target != origin) {\n     stack.push([origin, target])\n     map.set(origin, target);\n   }\n\n   while(stack.length) {\n     let [ori, tar] = stack.pop();\n     for (let key in ori) {\n\n        // 处理循环引用\n        if (map.get(ori[key])) {\n          tar[key] = map.get(ori[key]);\n          continue;\n       }\n\n       tar[key] = getEmpty(ori[key]);\n       if (ori[key] != tar[key]) {\n         stack.push([ori[key], tar[key]])\n         map.set([ori[key], tar[key]]);\n       }\n     }\n\n   }\n   return target;\n }\n")])])]),r("h3",{attrs:{id:"多条件查询函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多条件查询函数","aria-hidden":"true"}},[n._v("#")]),n._v(" 多条件查询函数")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("/**\n* 多条件查询函数\n* @param {Object} [condition] 条件\n* @param {Array} [source] 源数据\n*/\nfunction doFilter(source, condition) {\n  let searchForm = {};\n  for (let key in condition) {\n    if (condition.hasOwnProperty(key)) {\n      if (condition[key] !== '') {\n        searchForm[key] = condition[key]\n      }\n    }\n  }\n  if (JSON.stringify(searchForm) === '{}') return source;\n\n  return source.filter( item => {\n    return Object.keys( searchForm ).every( key => {\n      // 判断汉字正则\n      let isMatch = /^[\\u4e00-\\u9fa5]+$/.test(searchForm[ key ])\n        ? String( item[ key ] ).toLowerCase().indexOf(String( searchForm[ key ] ).trim().toLowerCase() ) !== -1\n        : String( item[ key ] ).toLowerCase() == String( searchForm[ key ] ).trim().toLowerCase()\n      return isMatch\n    })\n  })\n}\n")])])]),r("h3",{attrs:{id:"商品筛选器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#商品筛选器","aria-hidden":"true"}},[n._v("#")]),n._v(" 商品筛选器")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("const ProductFilters = {\n /**\n   * @param {array<Product>} products\n   * @param {array<{type: String, low: number, high: number}>} ranges\n   */\n  rangesFilter: function (products, ranges) {\n      if (ranges.length === 0) {\n          return products;\n      } else {\n          /**\n           * 循环多个区间条件，\n           * 每种区间类型应该只有一个，\n           * 比如价格区间不会有1000-2000和4000-6000同时需要的情况\n           */\n          for (let range of ranges) {\n              // 多个不同类型区间是与逻辑，可以直接赋值给自身\n              products = products.filter(function (item) {\n                  return item[range.type] >= range.low && item[range.type] <= range.high;\n              });\n          }\n          return products;\n      }\n  },\n\n  /**\n   * @param {array<Product>} products\n   * @param {array<{type: String, value: String}>} chooses\n   */\n  choosesFilter: function (products, chooses) {\n      let tmpProducts = [];\n      if (chooses.length === 0) {\n          tmpProducts = products;\n      } else {\n          /**\n           * 选择类型条件是或逻辑，使用数组连接concat\n           */\n          for (let choice of chooses) {\n              tmpProducts = tmpProducts.concat(products.filter(function (item) {\n                  return item[choice.type].indexOf(choice.value) !== -1;\n              }));\n          }\n      }\n      return tmpProducts;\n  }\n}\n")])])]),r("h3",{attrs:{id:"数组对象按属性分类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数组对象按属性分类","aria-hidden":"true"}},[n._v("#")]),n._v(" 数组对象按属性分类")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("/**\n * groupBy 数组对象按属性分类\n * @param {function} fn\n */\nfunction groupBy(array, f) {\n  var groups = {};\n  array.forEach(function (o) {\n      var group = JSON.stringify(f(o));\n      groups[group] = groups[group] || [];\n      groups[group].push(o);\n  });\n  return Object.keys(groups).map(function (group) {\n      return groups[group];\n  });\n}\n")])])]),r("h3",{attrs:{id:"判断回文字符串"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断回文字符串","aria-hidden":"true"}},[n._v("#")]),n._v(" 判断回文字符串")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("1. 解法一：使用API\nfunction isPlalindrome(input) {\n  if (typeof input !== 'string') return false;\n  return input.split('').reverse().join('') === input;\n}\n\n2. 解法二：不使用API\nfunction isPlalindrome(input) {\n  if (typeof input !== 'string') return false;\n  let i = 0, j = input.length - 1\n  while(i < j) {\n      if(input.charAt(i) !== input.charAt(j)) return false\n      i ++\n      j --\n  }\n  return true\n}\n")])])]),r("h3",{attrs:{id:"有效的括号"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有效的括号","aria-hidden":"true"}},[n._v("#")]),n._v(" 有效的括号")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("var isValid = function(s) {\n    let map = {\n        '{': '}',\n        '(': ')',\n        '[': ']'\n    }\n    let stack = []\n    for(let i = 0; i < s.length ; i++) {\n        if(map[s[i]]) {\n            stack.push(s[i])\n        } else if(s[i] !== map[stack.pop()]){\n            return false\n        }\n    }\n    return stack.length === 0\n};\n")])])]),r("h3",{attrs:{id:"删除字符串中的所有相邻重复项"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除字符串中的所有相邻重复项","aria-hidden":"true"}},[n._v("#")]),n._v(" 删除字符串中的所有相邻重复项")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("var removeDuplicates = function(S) {\n    let stack = []\n    for(c of S) {\n        let prev = stack.pop()\n        if(prev !== c) {\n            stack.push(prev)\n            stack.push(c)\n        }\n    }\n    return stack.join('')\n};\n")])])]),r("h3",{attrs:{id:"自定义定时器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#自定义定时器","aria-hidden":"true"}},[n._v("#")]),n._v(" 自定义定时器")]),n._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[n._v("/**\n* @description 写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal \n* @param {Function} [fn] 条件\n* @param {Number} [a] 时间\n* @param {Number} [b] 时间2\n*/\nfunction mySetInterval (fn, a, b) {\n  let _interval = [a, a + b, a + 2 * b];\n  let _currInterval = null;\n  let _index = 0;\n\n  const _mySetInterval = function(time) {\n    if (_index < _interval.length) {\n       clearInterval(_currInterval)\n      _currInterval = setInterval(() => {\n        fn()\n        _index++;\n        _mySetInterval(_interval[_index])\n      }, time);\n      return _currInterval\n    } else {\n      _index = 0;\n      _mySetInterval(_interval[_index])\n    }\n  }\n\n  _mySetInterval(_interval[_index]) \n  return _currInterval\n}\n\nfunction myClear(_interval) {\n  clearInterval(_interval)\n}\n\n\nfunction mySetInterval (fn, a, b) {\n  this.a = a;\n  this.b = b;\n  this.time = 0;\n  this.handle = null;\n\n  this.start = () => {\n    this.handle = setTimeout(() => {\n      fn();\n      this.time++;\n      this.start()\n    }, this.a + this.time * this.b)\n  }\n\n  this.stop = () => {\n    clearTimeout(this.handle)\n    this.time = 0;\n  }\n}\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);